from datetime import date
from typing import Tuple
from json import dump, load
import argparse

# TODO espn request for free agents by default only handles 'available' players
# TODO currently i edited the library but it needs to be properly overwritten dynamically

# TODO Implement Fantasy League Price adjustments
from espn_api import requests
from espn_api.hockey import League


def get_args() -> argparse.Namespace:
    """
    Get command line arguments
    """
    parser = argparse.ArgumentParser(description='Get credential values by loging into espn league, inspect page, '
                                                 'Application tab -> Storage -> Cookies -> "http://fantasy.espn.com". '
                                                 'Find required values in the list.')
    parser.add_argument('--league_id', type=int, help='Id of the fantasy league', required=True)
    parser.add_argument('--espn_s2', type=str, help='expn_s2 credentials value', required=True)
    parser.add_argument('--swid', type=str, help='swid credentials value', required=True)
    return parser.parse_args()


def get_league_config(_league_id) -> dict:
    """
    Return config for provided league
    :param int _league_id: ID of the espn league. League must be setup with 'init-new-league.py' prior to this.
    """
    with open('espn-data/{}/league-scoring-config.json'.format(_league_id)) as _f:
        return load(_f)


def get_years() -> list:
    """
    Generate a list of years to get data about players for.
    It starts at 2019 due to the fact that current API does not support earlier years.
    """
    init_year = 2019
    current_year = date.today().year
    current_month = date.today().month

    # next year season is generated by espn somewhere in August
    # predictions for the next season are generated by espn somewhere in September
    # hence the range offset, otherwise if run during Jan - July
    # it would try to request data for the year that does not exist
    offset = 2
    if current_month in range(1, 7):
        offset = 1

    ret = list(range(init_year, current_year+offset))
    # need to reverse the range, as current year is used as 'init' for the data schema
    # and uses players map from a current year
    ret.reverse()
    return ret


def setup_schema(_league_args) -> dict:
    """
    Returns a top level data structure (dict). Use with 'current year'.
    :param dict _league_args: Dict with values to use as **kvargs to get league info.
    :return: Dictionary with defined player ids.
    """
    league = League(**_league_args)
    schema = dict()
    schema['years'] = list()
    schema['draft'] = dict()
    schema['draft']['draft_years'] = list()
    schema['players'] = {key: dict() for key in league.player_map.keys() if isinstance(key, int)}
    for key in schema['players']:
        # noinspection PyTypeChecker
        schema['players'][key]['name'] = league.player_map[key]
    return schema


def get_fantasy_avg(_stats, _league_config, _is_goalie, _name) -> Tuple[float, float]:
    """
    returns fantasy avg value for players stats based on league scoring
    :param bool _is_goalie: Flag to indicate if player is a goalie
    :param str _name: Player name
    :param dict _stats: stats dictionary of a player.
    :param dict _league_config: League config dictionary to calculate points
    :return: calculated avg and total points as tuple value
    """

    def goalie_avg(_stats, _total):
        # there seems to be no cases in the data where there is total projected for the goalie while having zero starts
        # like in skaters projections
        return total / _stats['GS']

    def skater_avg(_stats, _total):
        games_played = 0

        try:
            games_played = _stats['GP']
        except KeyError:
            pass

        if not games_played:
            # sometimes projections data has zero for GP even though player has a projection for a season
            # assuming optimistic 78 games played a season
            games_played = 78

        return total / games_played

    avg = 0.0
    total = 0.0
    try:
        if _is_goalie:
            scoring = _league_config['scoring']['goaltenders']
        else:
            scoring = _league_config['scoring']['skaters']

        for key in scoring:
            if key not in _stats.keys():
                continue
            total += scoring[key] * _stats[key]

        if total:
            if _is_goalie:
                avg = goalie_avg(_stats, total)
            else:
                avg = skater_avg(_stats, total)

    except Exception as ex:
        # So far this happens for goalies that only came into games on relife and had zero game starts during a year
        print('\n!!!!\nProcessing a player "{}" has failed miserably!'.format(_name))
        print(ex)
        print('!!!!\n')
        return 0.0, 0.0
    return avg, total


def del_key(_dict, _key):
    """
    Delete a key and all it's values in a dictionary
    :param dict _dict: Dictionary containing the key
    :param str _key: Key to delete
    """
    if _key in _dict:
        del _dict[_key]


def aggregate_players_data(_full_data, _league_config, _free_agents, _year) -> dict:
    """
    Update main data with a data for current year
    :param dict _full_data: Dictionary containing full data
    :param dict _league_config: Data about Fantasy league, like scoring values
    :param list _free_agents: ESPN data of players in the league
    :param int _year: Year
    :return:
    """
    for player in _free_agents:
        try:
            is_goalie = False
            player_dict = clean_player_dict(vars(player), _year)

            if player_dict['position'] == 'Goalie':
                is_goalie = True
            for stat in player_dict['stats']:
                avg, total = get_fantasy_avg(
                    player_dict['stats'][stat]['total'],
                    _league_config,
                    is_goalie,
                    player.name
                )

                player_dict['stats'][stat]['total']['f_avg'] = avg
                player_dict['stats'][stat]['total']['f_total'] = total

            # update full data schema with players data
            _full_data['players'][player.playerId][_year] = player_dict
        except KeyError:
            print('Looks like a player {} has retired in the latest season. Data is dropped.'.format(player.name))
            continue

    return _full_data


def clean_player_dict(_player_dict, _year) -> dict:
    """
    Drops some data that is not important
    :param dict _player_dict: Player data
    :param int _year: Current year
    :return: returns lean player data
    """
    tmp = dict(_player_dict)
    del_key(tmp, 'name')
    del_key(tmp, 'playerId')
    del_key(tmp, 'lineupSlot')
    del_key(tmp, 'eligibleSlots')
    del_key(tmp, 'acquisitionType')
    del_key(tmp, 'injuryStatus')
    del_key(tmp, 'injured')
    tmp_stats = dict(tmp['stats'])
    for stat in tmp['stats']:
        # only keep Total and Projections data. This removes all 'last x days' stats
        if 'Total {}'.format(_year) in stat or 'Projected {}'.format(_year) in stat:
            pass
        else:
            del_key(tmp_stats, stat)
    tmp['stats'] = dict(tmp_stats)
    return tmp


def parse_draft_data(_full_data, _draft, _year) -> dict:
    """
    Update players data with a draft data for a current year
    :param dict _full_data: Full players` data
    :param dict _draft: Draft data for this year
    :param int _year: current year
    :return: Updated data with draft values
    """
    # check if draft completed for current year
    if not _draft['draftDetail']['drafted']:
        return _full_data

    # record draft year into full data
    _full_data['draft']['draft_years'].append(_year)
    _full_data['draft'][_year] = dict()
    _full_data['draft'][_year]['salary_cap'] = _draft['settings']['draftSettings']['auctionBudget']
    # parse over draft
    for pick in _draft['draftDetail']['picks']:
        player_id = pick['playerId']
        try:
            _full_data['players'][player_id][_year]['draft_pick'] = pick['id']
        except KeyError:
            # current drafted player is not in the full data, most likely retired in most recent year
            continue
        _full_data['players'][player_id][_year]['draft_keeper'] = pick['keeper']
        _full_data['players'][player_id][_year]['draft_price'] = pick['bidAmount']
        _full_data['players'][player_id][_year]['draft_cap_percentage'] = get_price_to_cap_percentage(
            _draft['settings']['draftSettings']['auctionBudget'], pick['bidAmount'])

    return _full_data


def get_price_to_cap_percentage(_cap, _player_price) -> float:
    """
    :param int _cap: Salary cap for the year
    :param int _player_price: Players draft price
    :return: How much of the cap in percentage player salary is
    """
    return round(_player_price / _cap * 100, 2)


def main(_league_id, _espn_s2, _swid):
    """
    Main
    :param int _league_id: Fantasy League ID
    :param string _espn_s2: Auth value of 'espn_s2' cookie
    :param string _swid: Auth value of 'swid' cookie
    """
    kwargs = {
        'league_id': _league_id,
        'espn_s2': _espn_s2,
        'swid': _swid
    }

    league_config = dict()
    try:
        league_config = get_league_config(kwargs['league_id'])
    except FileNotFoundError:
        print('Unable to locate configuration for League_id: {}.'
              '\nSetup with "init-new-league.py"'.format(kwargs['league_id']))
        exit(-1)

    years = get_years()
    kwargs['year'] = years[0]
    full_data = setup_schema(kwargs)
    for year in years:
        print('Getting data for year {} ...'.format(year))
        kwargs['year'] = year
        try:
            league = League(**kwargs)
            full_data['years'].append(year)
            fa = league.free_agents(size=10000)

            draft = league.espn_request.get_league_draft()
            full_data = aggregate_players_data(full_data, league_config, fa, year)
            full_data = parse_draft_data(full_data, draft, year)

        except requests.espn_requests.ESPNAccessDenied:
            print("Logged-in user does not have access to year {}".format(year))
            pass

    with open('espn-data/{}/player-draft-data.json'.format(kwargs['league_id']), '+w') as _f:
        dump(full_data, _f, indent=2)

    print()


if __name__ == '__main__':
    args = get_args()
    main(args.league_id, args.espn_s2, args.swid)
